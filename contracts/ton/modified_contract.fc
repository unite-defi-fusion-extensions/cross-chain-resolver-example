;; Modified TON cross-chain escrow contract implementing hash‑timelocked swaps.
;;
;; This version is based off the user‑provided code and includes a few changes
;; suggested in the accompanying analysis:
;;   * The `completeSwap` function now transfers Jettons to the `recipient` of
;;     the swap instead of the `initiator` (the original depositor).  This
;;     matches the typical behaviour of a cross‑chain atomic swap where the
;;     taker on one chain receives the maker’s funds once the secret is
;;     revealed.
;;   * The hash used to verify the secret continues to be `sha256` because
;;     FunC does not currently expose a Keccak primitive.  If you integrate
;;     with an EVM escrow that uses `keccak256`, ensure that both sides agree
;;     on the same hash function and compute the hash off‑chain accordingly.
;;   * Comments have been added to highlight where a safety deposit could be
;;     implemented.  Implementing safety deposits requires additional state
;;     (e.g. an extra field in the swap record) and transfer of TON grams to
;;     the caller of `completeSwap`/`refundSwap`, which is outside the scope of
;;     this example.

#include "stdlib.fc";
#include "error-codes.fc";
#include "helpers.fc";

;; -----------------------------------------------------------------
;; GETTERS (for off-chain calls)
;; -----------------------------------------------------------------
int get_swap_counter() method_id {
    var (_, swapCounter, _, _) = load_data();
    return swapCounter;
}

slice get_jetton_wallet() method_id {
    var (jettonWallet, _, _, _) = load_data();
    return jettonWallet;
}

int has_swap(int swapId) method_id {
    var (_, _, swaps, _) = load_data();
    var (_, found) = swaps.udict_get?(256, swapId);
    return found ? 1 : 0;
}

(slice, slice, int, int, int, int) get_swap(int swapId) method_id {
    var (_, _, swaps, _) = load_data();
    var (swapData, found) = swaps.udict_get?(256, swapId);
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    return parseSwap(swapData);
}

(int, slice, slice, int, int, int, int) get_swap_by_hashlock(int hashlock) method_id {
    var (_, _, swaps, hashlock_map) = load_data();
    
    var (swapId_cs, found) = hashlock_map.udict_get?(256, hashlock);
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    
    int swapId = swapId_cs.preload_uint(256);
    
    var (swapData, swap_found) = swaps.udict_get?(256, swapId);
    throw_unless(ERR_SWAP_NOT_FOUND, swap_found);
    
    var (initiator, recipient, tokenAmount, current_hashlock, timeLock, isCompleted) = parseSwap(swapData);
    return (swapId, initiator, recipient, tokenAmount, current_hashlock, timeLock, isCompleted);
}

;; refundSwap: Refunds a swap if the timelock has expired.
() refundSwap(slice in_msg_body, int msg_value) impure {
    var (jettonWallet, swapCounter, swaps, hashlock_map) = load_data();
    
    int swapId = in_msg_body~load_uint(256);
    
    var (swapData, found) = swaps.udict_get?(256, swapId);
    
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    
    var (initiator, recipient, tokenAmount, hashLock, timeLock, isCompleted) = parseSwap(swapData);
    
    throw_if(ERR_SWAP_ALREADY_COMPLETED_REFUND, isCompleted);
    
    int current_timestamp = now();
    
    throw_if(ERR_TIMELOCK_NOT_EXPIRED, current_timestamp < timeLock);
    
    builder newSwap = buildSwap(initiator, recipient, tokenAmount, hashLock, timeLock, 1);
    swaps~udict_set(256, swapId, newSwap.end_cell().begin_parse());
    
    ;; At refund time the original depositor (initiator) should get their tokens back.
    sendJettonTransfer(jettonWallet, initiator, tokenAmount, msg_value);
    
    ;; NOTE: safety deposit refund could be sent here if implemented.
    
    save_data(jettonWallet, swapCounter, swaps, hashlock_map);
}

;; depositNotification: Stores a new swap when Jettons are transferred to this contract.
() depositNotification(slice sender_address, slice in_msg_body, int amount) impure {
    var (jettonWallet, swapCounter, swaps, hashlock_map) = load_data();
    
    int depositAmount = 0;
    try {
        depositAmount = in_msg_body~load_uint(128);
    } catch (_, _) {
        return ();
    }

    throw_unless(ERR_INVALID_AMOUNT, depositAmount == amount);
    
    slice depositor = null();
    try {
        depositor = in_msg_body~load_msg_addr();
    } catch (_, _) {
        return ();
    }
    
    if (in_msg_body.slice_refs() < 2) {
        return ();
    }
    
    slice recipient = null();
    try {
        cell recipientRef = in_msg_body~load_ref();
        slice recipientSlice = recipientRef.begin_parse();
        recipient = recipientSlice~load_msg_addr();
    } catch (_, _) {
        return ();
    }
    
    int hashLock = 0;
    int timeLock = 0;
    try {
        cell locksRef = in_msg_body~load_ref();
        slice locksSlice = locksRef.begin_parse();
        hashLock = locksSlice~load_uint(256);
        timeLock = locksSlice~load_uint(64);
    } catch (_, _) {
        return ();
    }
    
    try {
        storeSwap(
            jettonWallet,
            swapCounter,
            swaps,
            hashlock_map,
            depositor,
            recipient,
            depositAmount,
            hashLock,
            timeLock
        );
    } catch (_, _) {
        throw(ERR_FAILED_DEPOSIT_NOTIFICATION);
    }
}

;; completeSwap: Completes a swap if a valid preimage is provided.
() completeSwap(slice in_msg_body, int msg_value) impure {
    var (jettonWallet, swapCounter, swaps, hashlock_map) = load_data();
    
    int swapId = in_msg_body~load_uint(256);
    int preimage = in_msg_body~load_uint(256);
    
    var (swapData, found) = swaps.udict_get?(256, swapId);
    throw_unless(ERR_SWAP_NOT_FOUND, found);
    
    var (initiator, recipient, tokenAmount, hashLock, timeLock, isCompleted) = parseSwap(swapData);

    throw_if(ERR_SWAP_COMPLETED, isCompleted);
    
    ;; Compute the hash of the preimage.  We continue to use sha256 for
    ;; compatibility with FunC.  If using keccak256 on the EVM side, ensure the
    ;; hashlock values are computed off‑chain and stored consistently on both chains.
    int calculatedHash = sha256_int256(preimage);
    throw_unless(ERR_INVALID_PREIMAGE, calculatedHash == hashLock);
    
    throw_if(ERR_TIMELOCK_EXPIRED, now() >= timeLock);
    
    ;; Mark this swap as completed.
    builder newSwap = buildSwap(initiator, recipient, tokenAmount, hashLock, timeLock, 1);
    swaps~udict_set(256, swapId, newSwap.end_cell().begin_parse());
    
    ;; Transfer the locked Jettons to the recipient (the taker on this chain).
    ;; In the original contract the transfer was made back to the initiator,
    ;; which prevented cross‑chain delivery of funds.  This change sends the
    ;; tokens to the intended beneficiary.
    sendJettonTransfer(jettonWallet, recipient, tokenAmount, msg_value);
    
    ;; NOTE: If you implement a safety deposit, you should also send the deposit
    ;; (grams) to the caller here as a reward for completing the swap.
    
    save_data(jettonWallet, swapCounter, swaps, hashlock_map);
}

;; -----------------------------------------------------------------
;; The main entry point
;; -----------------------------------------------------------------
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    
    if (op == OP_COMPLETE_SWAP) {
        completeSwap(in_msg_body, msg_value);
        return ();
    }
    
    if (op == OP_REFUND_SWAP) {
        refundSwap(in_msg_body, msg_value);
        return ();
    }
    
    if (op == 0x7362d09c) { ;; JETTON_TRANSFER_NOTIFICATION
        int queryId = in_msg_body~load_uint(64);
        int tokenAmount = in_msg_body~load_coins();
        
        try {
            throw_if(ERR_INVALID_FROM_ADDRESS, in_msg_body.slice_data_empty?());
        } catch (err) {
            throw(242422424);
        }
        
        slice from_address = null();
        try {
            from_address = in_msg_body~load_msg_addr();
        } catch (err) {
            throw(ERR_FAILED_LOAD_MSG_ADDR);
        }
        
        try {
            throw_if(ERR_INVALID_FROM_ADDRESS, from_address.slice_empty?());
        } catch (err) {
            throw(ERR_FAILED_CHECKING_SLICE_EMPTY);
        }
        
        try {
            throw_if(ERR_INVALID_AMOUNT_TRANSFER, in_msg_body.slice_data_empty?());
        } catch (err) {
            throw(ERR_FAILED_CHECKING_SLICE_DATA_EMPTY);
        }
        
        try {
            throw_if(ERR_INVALID_RESPONSE_ADDRESS, in_msg_body.slice_data_empty?());
        } catch (err) {
            throw(ERR_FAILED_CHECKING_SLICE_DATA_EMPTY);
        }
        
        slice response_address = sender_address;
        
        int slice_refs_count = 0;
        try {
            slice_refs_count = in_msg_body.slice_refs();
        } catch (err) {
            throw(ERR_FAILED_SLICE_REFS_COUNT);
        }
        
        throw_if(ERR_NO_REFS, slice_refs_count == 0);
        
        if (slice_refs_count > 0) {
            try {
                throw_if(ERR_INVALID_FORWARD_PAYLOAD, in_msg_body.slice_refs_empty?());
            } catch (err) {
                throw(ERR_FAILED_CHECKING_REFS_EMPTY);
            }
        
            cell forward_payload = null();
            try {
                forward_payload = in_msg_body~load_ref();
            } catch (err) {
                throw(ERR_FAILED_LOAD_REF);
            }
        
            slice forward_payload_slice = null();
            try {
                forward_payload_slice = forward_payload.begin_parse();
            } catch (err) {
                throw(ERR_FAILED_PARSE_FORWARD_PAYLOAD);
            }
        
            try {
                throw_if(ERR_INVALID_FORWARD_PAYLOAD, forward_payload_slice.slice_empty?());
            } catch (err) {
                throw(ERR_FAILED_CHECKING_SLICE_EMPTY);
            }
        
            slice forward_slice = null();
            try {
                forward_slice = forward_payload.begin_parse();
            } catch (err) {
                throw(ERR_FAILED_PARSE_FORWARD_SLICE);
            }
        
            try {
                throw_if(ERR_INVALID_FORWARD_SLICE, forward_slice.slice_empty?());
            } catch (err) {
                throw(ERR_FAILED_CHECKING_SLICE_EMPTY);
            }
        
            int forward_slice_bits = 0;
            try {
                forward_slice_bits = forward_slice.slice_bits();
            } catch (err) {
                throw(ERR_FAILED_GET_SLICE_BITS);
            }
        
            throw_if(ERR_INSUFFICIENT_BITS, forward_slice_bits < 32);
        
            if (forward_slice_bits >= 32) {
                int forward_op = 0;
                try {
                    forward_op = forward_slice~load_uint(32);
                } catch (err) {
                    throw(ERR_FAILED_LOAD_UINT);
                }
            
                throw_if(ERR_INVALID_FORWARD_OP, forward_op <= 0);
            
                if (forward_op == OP_DEPOSIT_NOTIFICATION) {
                    depositNotification(sender_address, forward_slice, tokenAmount);
                    return ();
                }
            }
        }
        return ();
    }
}